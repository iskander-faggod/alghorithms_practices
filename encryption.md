# Кодирование

**Кодирование** - процесс при котором мы преобразуем последовательность данных в более облегченный вариант записи с целью восстановления его состояния и уменьшения памяти, потраченной на его хранения.

## Хаффман 

**Идейно**:

Пусть **A**={a1,a2,…,an}
 — алфавит из n
 различных символов

 **W**={w1,w2,…,wn}
  — соответствующий ему набор положительных целых весов.

Где **А** это элемент алфавита, **W** - количество повторений в наборе символов из алфавита **A**.

**C**={c1,c2,…,cn}
, где ci
 является кодом для символа ai
, такой, что:

1) ci
 не является префиксом для cj
, при i≠j

2) cумма ∑i∈[1,n]wi⋅|ci|
 минимальна (|ci|
 — длина кода ci
)

Если переводить на простой язык, по факту это коллекция для агрегации данных. На каждом i..n находим такие Wi, что их сумма минимальна и сжимаем коллекцию. 

называется кодом **Хаффмана**

**Алгоритм работы:**

Построение кода Хаффмана сводится к построению соответствующего бинарного дерева по следующему алгоритму:

1) Составим список кодируемых символов, при этом будем рассматривать один символ как дерево, состоящее из одного элемента c весом, равным частоте появления символа в строке.

2) Из списка выберем два узла с наименьшим весом.

3) Сформируем новый узел с весом, равным сумме весов выбранных узлов, и присоединим к нему два выбранных узла в качестве детей.

4) Добавим к списку только что сформированный узел вместо двух объединенных узлов.
Если в списке больше одного узла, то повторим пункты со второго по пятый.

## Хемминг

Более неформальное объяснение будет, тк инфы нормальной нет.

Есть кейсы, когда при передаче информации возникают различного рода ошибки. Эти ошибки как раз и можно выявить с помощью алгоритма Хемминга и исправить.

Например возьмем ход 10110101

__Для удобства начнем нумерацию с 1__

[1,0,1,1,0,1,0,1] - разобьем на символы и выделим опорные точки

Опорная точка - значение, под индексов степени двойки.

Получаем опорные точки: [1,2,4,8], на этих позициях ставим образные символы, например *

Таким образом увеличиваем коллекцию на n + (количество степеней двоек по индексам)

Выписываем обратно значения из массива, учитывая опорные точки

[*, *, 1, *, 0, 1, 1, *, 0, 1, 0, 1]

Теперь для каждой точки составляем цепочку, цепочка составляется путем взятия и скипа k элементов, где k - индекс опорной точки. Подсчитываем кол-во единиц на получившемся отрезке и, если кол-во четное - пишем 0. Если нечетное пишем 1 вместо звездочки


Например: 

1 - [1, 0, 1, 0, 0]

2 - [1, 1, 0, 1]

4 - [0, 1, 1, 1]

8 - [0, 1, 0, 1]

Дальше давайте проверим 11-й индекс на ошибку например. Поменяем 0 на 1 в изначальной коллекции символов и проверим, где мы допустили ошибку (исскуственно).

По аналогии с предыдущим этапом будем определять значения для ключевых точек

Например: 

1 - [1, 0, 1, 0, 1] - не совпадает

2 - [1, 1, 1, 1] - не совпадает

4 - [0, 1, 1, 1] - совпадает

8 - [0, 1, 1, 1] - не совпадает

Сложив индексы неправильных опорных точек, получим индекс ячейки в которой лежит битое значение:

1 + 2 + 8 = 11. 

Done